# javascript函数参数传递

## 一，基本类型vs引用类型

#### 1，内存存储原理

| 类型     | 存储位置 | 访问方式     | 典型案例   |
| -------- | -------- | ------------ | ---------- |
| 基本类型 | 栈内存   | 直接访问值   | let a=10   |
| 引用类型 | 堆内存   | 通过地址访问 | let obj={} |

#### 2，动态属性实验

基本类型不可扩展-----引用类型可以扩展

## 二，复制行为

#### 1，基本类型复制

~~~js
let a=10；
let b=a；//复制，创建新的独立副本

b=20；
console.log(a)//10
~~~

#### 2，引用类型复制

~~~Js
let obj1={count:1};
let obj2=obj1;

obj2.count=2;
console.log(obj1.count)//2,修改连同，因为是地址
~~~

## 三，函数参数传递的真相

#### 1，参数传递的本质

- 基本类型传递值的**副本**
- 引用类型传递地址的**副本**

#### 2，经典案例

###### 1：修改属性

~~~Js
function changeName(obj){
    obj.name="bob"
}
const person={name:'Alice'};
changeName(person)
console.log(person.name)//bob✔
~~~

解读：根据参数按值传递的原理，person定义的时候person保存了对象的地址（其实更准确是对象的**引用**-地址值），调用函数的时候，person传递给obj的是对象的地址的副本（其实不是共享一个地址变量，而是地址复制成了两份），但是person和obj是两个不同的变量，这样函数内部obj.name的修改可以修改obj和person指向的堆内存的对象的name

###### 2：重新赋值

~~~Js
function replaceObj(obj){
    obj={name:"Alice"}
    //这里直接修改了obj的指向，而不是把这个对象整个替换
    //没办法直接把堆内存中已经存在的对象整个换成新对象，上面的操作仅仅是在改变指向，让obj指向新对象{}
}
const person={name:"bob"}
replaceObj(person)
console.log(person.name)
~~~

解读：重新赋值，就是把obj重新赋值

###### 3：混合操作

~~~js
function mixUpdate(obj){
	obj.age=30;
    obj={name:"David"}
}
const person={name:"Alice"}
mixUpdate(person)
console.log(person);
~~~

解读：混合操作，先把obj的age改了，再把obj重新赋值，但是person指向对象内容还是修改了，如果mixUpdate操作反过来，person没有任何修改

## 四，面试题？！

题1：输出？

~~~js
let a=[1,2];
function fn(b){
    b.push(3)
    b=[4,5];//这时候b就重新赋值了
}
fn(a);
console.log(a);
//输出[1,2,3]
~~~

题2：如何实现真正的对象复制？

~~~js
//浅拷贝方案
const shallowCopy={...obj};

//深拷贝方案
const deepCopy=JSON.parse(JSON.stringify(obj));
~~~

题3：函数参数按引用传递吗

~~~js
function change(srg){
    srg=100;
}
const a=10;
change(a);
console.log(a)//10,说明是按值传递
~~~

~~~Js
function setName(obj){
    obj.name="Nicholas";
    obj=new Object();
    //这里如果是按引用，那么person直接就被修改为greg这个了，说明obj里边的只是一个副本罢了，不是本体
    obj.name="greg";
}
var person=new Object();
setName(person);
alert(person.name);//"Nicholas"
~~~

>person是按引用传递的，那么person就会被自动修改为新对象（“greg”）。
>
>但是接下来访问person，其指向的name却是“nicholas”
>
>实际上，obj=newObject的时候，引用的是一个局部对象，完事后这个局部对象会立刻被销毁。

## 五，实践

1，避免副作用

~~~js
function updateUser(user){
    return {...user,age:user.age+1};
}
~~~

2,防御性编程

~~~Js
//冻结重要配置？
const config = Object.freeze({
  apiUrl: 'https://api.example.com'
});
~~~

3,性能优化

~~~js
//大对象处理：使用共享内存
const buffer=new SharedArrayBuffer（1024）
~~~

## 六，图谱总结

| 核心概念     | 关键要点           | 误区                       |
| ------------ | ------------------ | -------------------------- |
| 基本类型复制 | 创建独立副本       | 引用类型不是值复制         |
| 引用类型复制 | 复制地址引用       | 复制的不是整个对象，是地址 |
| 函数参数传递 | 本质都是**值传递** | 引用类型也是按值传递       |
| 动态属性     | 仅引用类型可扩展   | 基本类型不能添加属性       |

js中所有数据交互都是值传递。

按引用传递的话：传递的是对象**引用本身**了，而不是副本，内部修改会直接影响外部变量

