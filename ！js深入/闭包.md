

# 闭  包

典中典了这位，一直听过，一直不清楚

## 一，什么事闭包

> MDN言：闭包事指那些能访问自由变量的函数

[^自由变量]: 在函数中使用的，但是既不是函数参数，也不是函数内部声明的变量
[^闭包]: 函数+函数能够访问到的自由变量的集合（作用域）

>老人言：函数记住了它被定义时的作用域，即便这个函数实在另一个作用域被调用

简单说：

我们把引用了其他函数作用域变量的函数和被引用变量的集合，称为闭包

当函数返回了另一个函数的时候，实际上他返回了一个闭包

## 二，闭包理解案例

案例1：定时器和<u>var</u>的陷阱

~~~js
for(var i=0;i<5;i++){
    setTimeout(()=>console.log(i),1000);
}
//5,5,5,5,5
~~~

奇怪了

>因为，setTimeout事异步的，有这个时间，循环早就循环完了(闭包引用的事一个i变量)

~~~Js
//方式一：let(块级作用域)
for(let i=0;i<5;i++){
	setTimeout(()=>console.log(i),1000);
}
//为什么？EMCAscript对for循环的let声明规定提出，let位于for首时，每次迭代都会创建一个新的词法环境，并且将每个迭代的变量绑定到新词法环境中

//方式二：IIFE+闭包
for(var i=0;i<5;i++){
    ((j)=>{
        setTimeout(()=>console.log(j),1000);
    })
}
//不懂！
~~~

案例2：函数工厂

~~~js
function capMarker(){
	let count=0;
	return function(){
		count++;
        console.log(count)
    }
}
const cap=capMarker()
//cap就是返回的函数！
capMarker()//1
capMarker()//2

//函数cap是一个闭包，记住了capMarker的作用域链，即count始终存在
~~~

## 三，闭包的<u>原理</u>（作用域链）

闭包的原理jo是：在函数被定义的时候就已经“捕获”了他的外部作用域

作用域链图示：

~~~js
function outer(){
    let a=10l
    return function inner(){
	console.log(a);//访问的是outer的作用域
    }
}
~~~

当inner()被返回并在外部执行时，记住了outer的作用域，依然可以访问a。

因为，JS引擎在创建函数时就创建了作用域链，并且将这个作用域链与对应作用域一并储存。

## 四，闭包的应用场景

| 应用场景         | 示例                               |
| ---------------- | ---------------------------------- |
| 私有变量         | 使用闭包模拟私有变量，避免全局污染 |
| 防抖/节流函数    | 利用闭包保存定时器变量             |
| 工厂函数         | 工厂模式中生成带状态的函数         |
| 缓存             | 封装函数，缓存某次计算结果         |
| 异步操作（回调） | 保持异步状态变量的正确性           |

### 1，封装私有变量

防止被外部访问和修改。**防止被全局变量污染**，闭包将这些变量限制在函数/模块内部，减少了全局变量的数量，**降低了全局变量被误用/意外修改的风险**。

~~~js
function add(){
    let count=0;
    count++;
    console.log(count);
}
add()//1
add()//1
add()//1
~~~

除了把**count提出来**的办法外，就是我们的**闭包**方法

~~~js
function add(){
    let count=0
    function a(){
        count++
        console.log(count)
    }
    return a
}
var add=add()
add()//1
add()//2
add()//3
~~~

返回了一个闭包a，这个闭包a包含a函数和外边的count变量。

如果把count存到全局去，很可能被污染（同事计数的时候也弄了个count，你们俩变量就冲突了），但是，把这个count用闭包私有起来，外部访问不到，但是内部可以访问。

因为a引用了count，所以，闭包把count一并储存了，因此count可以在闭包内部被修改访问

这样就实现了私有数据和逻辑的封装

#### 2，做缓存

函数一旦被执行完毕，内存就会被销毁，而闭包可以保住作用域。

~~~js
function foo(){
    var myName='张三'
    let test1=1
    const test2=2
    var innerBar={
        getName:function(){
            console.log(test1);
            return myName;
        },
        setName:function(){
            myName=newName
        }
    }
    return innerBar
}
var bar=foo()
console.log(bar.getName());//1 zhangsan

bar.setName('lisi')
console.log(bar.getName());//输出：1 lisi
~~~

这里var bar=foo()执行完后本来应该被销毁，但是因为形成了闭包，所以被引用的myName，test1没被销毁，保留了下来，在闭包里面。

什么意思呢，首先，var这句话确实引用了foo，

foo执行完后，foo的执行上下文（创建变量对象的那个）就被销毁了，

~~~js
但是由于里边的getName和setName函数狠狠引用了test1和myName，所以test1和myName这个本该被销毁的变量得以缓存
~~~

这样理解不准确，1，不是引用了变量，还是函数的environment指向了foo的作用域，得以保存，所以可以运用test1和myName这两个变量2，实际上是foo函数的作用域被缓存了，即使没被引用，依然保存

后续getName使用的时候能访问到到这两个变量

#### 3，模块化编程

~~~js
function my=(function(){
    let private='我是私有的'
    function usePrivate(){
        console.log(private);
    }
    return {
        usePrivate:function(){
		usePrivate();
        }
    }
})();//这样是立即执行函数
my.usePrivate（）//输出：我是私有的
~~~

外部不需要了解内部是怎么处理private的，但是可以直接使用my函数，达成一个封装模块(包括私有变量，私有方法，公共接口的完整功能单元)，而且因为立即执行，里边的变量不会污染全局。而闭包的作用是让内部变量在执行后不销毁，供接口使用。

## 五，闭包的注意事项

###### 1，闭包会导致变量不被垃圾回收

*长期存在的闭包可能导致内存泄露

###### 2，不合理使用闭包只会增加代码复杂度

建议只在需要记住状态或函数返回函数的场景中使用闭包

两种方法解决内存泄露问题

>1，及时释放闭包：手



## 总结

- 闭包是函数+定义时的作用域
- 他能访问外部函数的局部变量
- 理解作用域链，是理解闭包的关键
- 广泛运用在工厂函数、私有变量、节流防抖、缓存中
- 注意内存管理，避免闭包导致的泄露

