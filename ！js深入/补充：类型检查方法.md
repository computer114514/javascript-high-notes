# 补充：类型检查方法

typeof，instanceof，Object.prototype.toString

## typeof运算符

#### ✅作用：

用于检测**变量**的**基本数据类型**（原始类型）。

#### 🔍小实例

~~~Js
console.log(typeof 2)//"number"
console.log(typeof true)//"boolean"
console.log(typeof "tiansuo")//string
console.log(typeof [])//object
console.log(typeof {})//obejct  数组和对象搞不清楚,
console.log(typeof function(){})//function 函数倒还是搞得清楚的嘛!
console.log(typeof null)//object
console.log(typeof undefined)//undefined
~~~

#### 📌特点与限制

| 类型                  | typeof检测结果             |
| --------------------- | -------------------------- |
| 基本类型              | 正确无误                   |
| Null                  | 错误返回"object"(历史问题) |
| 对象（Object、Array） | “obejct”                   |
| 函数                  | “function”                 |

#### 😊优点

简单有高效

正确识别基本类型

#### ❌缺点

无法区别对象和数组

null被错误识别为“object”

不能检测Symbol、BigInt复杂类型；

## instanceof运算符

✅作用：用于检测**某对象**是否是由**某个构造函数**的实例（即其原型链中是否有该构造函数的原型）

### 🛑示例代码

~~~Js
console.log(1 instanceof Number)
//false,因为1,"string",true本身不是对象，是原始值，所以不是Number创建出来的实例
//很少见的new Number()，这倒是Number创建的对象
console.log("string" instanceof String)
//false,因为string只是原始类型数据，不是String创建的实例
console.log("true" instanceof boolean)
//false,同上，题目也说了判断的是对象

console.log([] instanceof Array)//true
//这是Array的实例
console.log(function()[] instanceof Function)
//这是function的实例
console.log({}instanceof Object)//true
//这是object的实例
~~~

### 📌特点与限制

| 类型         | 检测结果 |
| ------------ | -------- |
| **原始**类型 | false    |
| 引用类型     | true     |

## constructor属性

### ✅作用

每个**对象**都有一个constructor属性，指向创建他的函数

每个函数（fn）创建时，就会在自己的原型函数里创建一个constructor属性指向自己（fn），这样，实例才可以调用这个constructor函数，指向fn

——你猜为什么实例有一个constructor元素可以使用，还有__proto_ _元素可以使用？还不是因为fn的prototype里边有这两个属性？

### 🛑示例代码

~~~Js
console.log((2).constructor===Number)//true
~~~

### 📌注意事项

~~~js
function Fn(){}
Fn.prototype=new Array();
var f=new Fn();

console.log(f.constructor===Fn)//false
console.log(f.constructor===Array)//true
~~~

为什么会这样？

fn.prototype里边**有了constructor函数**，而第二行的操作直接**把prototype里面的constructor改成Array了**，所以实例f的constructor指向的就是Array了。

>所以少用constructor，因为他太容易被篡改了

📞喂喂喂，有个点要注意一下，这个结论和上面instanceof的结论矛盾了不是，其实这边有个.constructor调用了方法，JS引擎自动装箱，把这个数字当成了一个对象！但是用完就销毁了。

### 😀优点

可以检测**基本类型**(instanceof做不到)

能获取构造函数信息（constructor）

### 😟缺点

·修改了原型链，判断就不准确了

·严格模式会产生不知名错误

·安全性低，容易被覆盖

## 4，Object.prototype.toString.call()方法

### ✅ 作用：

这是最通用可靠的数据类型检测方式。它返回[object Type]格式的字符串，表示对象的具体类型。

###### object.prototype.toString.call()

~~~js
object.prototype.toString.call(2)
//console.log=[object Number]
object.prototype.toString.call([])
//console.log=[object Number](2)
~~~

#### 为什么不用obj.toString?要用Object的

内置对象重写了toString方法（因为toString被内置对象本地化了，不是原始的、原汁原味的Object的方法了）

~~~Js
Array.prototype.toString()
//本土化返回的就是元素形成的字符串.

object.prototype.toString()
//本土化返回的就是函数体的字符串表示
~~~

诸如此类。

> 使用Object.prototype.toString.call()**完美绕开**了这些重写，**直接调用**了原生的方法，**返回**标准格式的类型标识。

✅ **优点**：

- 准确判断所有内置类型
- 不受原型链影响
- 兼容性号，使用大多浏览器、环境

❌缺点：

- 写法有点烦（你的第一印象）
- 不能检测自定义类的类型（除非你自己实现Symbol.toStringTag);

## 总结

| 检测方式                         | 可以检测基本类型吗？ | 可以检测引用类型吗？        | null是否可以判断？ | 是否受原型影响？ | 推荐指数？ |
| -------------------------------- | -------------------- | --------------------------- | ------------------ | ---------------- | ---------- |
| typeof                           | 可以                 | ❌不准确（对象数组都分不清） | ❌                  | ❌                | ⭐⭐⭐        |
| instanceof                       | ❌                    | 可以                        | ❌                  | 受               | ⭐⭐⭐⭐       |
| constructor                      | 可以                 | 可以                        | 可以               | 受               | ⭐⭐         |
| Object.prototype.to Sring.call() | 可以                 | 可以                        | 可以               | ❌                | ⭐⭐⭐⭐⭐      |

## 尾声

javascript中，typeof用于检测**基本**数据类型，

constructor、instanceof用于检测**引用**数据类型，

而Object.prototype.toString()是**万金油**，都可以判断。